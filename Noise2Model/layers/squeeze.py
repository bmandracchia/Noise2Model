# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/02_layers_squeeze.ipynb.

# %% auto 0
__all__ = ['squeeze_spatial', 'unsqueeze_spatial', 'SqueezeLayer']

# %% ../../nbs/02_layers_squeeze.ipynb 3
from fastai.vision.all import nn

# %% ../../nbs/02_layers_squeeze.ipynb 5
def squeeze_spatial(input, factor=2):
    assert factor >= 1 and isinstance(factor, int), "Factor must be a positive integer."
    
    if factor == 1: return input
    
    dim = input.dim()
    assert dim >= 3 and dim <= 5, "Input tensor must have 3D, 4D, or 5D dimensions."
    
    sizes = list(input.size())
    batch_size, channels = sizes[:2]
    spatial_dims = sizes[2:]
    
    for dim_idx in range(len(spatial_dims)):
        assert spatial_dims[dim_idx] % factor == 0, "Spatial dimension {} is not divisible by the factor.".format(dim_idx)
        sizes[dim_idx + 2] //= factor
    
    input = input.view(batch_size, channels, *spatial_dims)  # Ensure contiguous memory
    
    new_channels = channels * (factor ** (dim_idx + 1))
    new_spatial_dims = sizes[2:]

    return  input.view(batch_size, new_channels, *new_spatial_dims)


# %% ../../nbs/02_layers_squeeze.ipynb 7
def unsqueeze_spatial(input, factor=2):
    assert factor >= 1 and isinstance(factor, int), "Factor must be a positive integer."
    
    if factor == 1: return input
    
    dim = input.dim()
    assert dim >= 3 and dim <= 5, "Input tensor must have 3D, 4D, or 5D dimensions."
    
    sizes = list(input.size())
    batch_size, channels = sizes[:2]
    spatial_dims = sizes[2:]
    
    sizes = [sizes[0], sizes[1]]
    for dim_idx in range(len(spatial_dims)):
        sizes.append(spatial_dims[dim_idx] * factor)
            
    input = input.view(batch_size, channels, *spatial_dims)  # Ensure contiguous memory
    
    new_channels = channels // (factor ** (len(spatial_dims)))
    new_spatial_dims = sizes[2:]
    
    return  input.view(batch_size, new_channels, *new_spatial_dims)


# %% ../../nbs/02_layers_squeeze.ipynb 9
class SqueezeLayer(nn.Module):
	def __init__(self, factor, level, name='squeeze'):
		super(SqueezeLayer, self).__init__()
		self.factor = factor
		self.name = name
		self.level = level

	def _inverse(self, z, **kwargs):
		output = unsqueeze_spatial(z, self.factor)
		return output

	def _forward_and_log_det_jacobian(self, x, **kwargs):
		output = squeeze_spatial(x, self.factor)
		return output, 0

